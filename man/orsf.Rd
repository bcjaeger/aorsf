% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orsf_fit.R
\name{orsf}
\alias{orsf}
\alias{orsf_train}
\title{Oblique Random Survival Forest (ORSF)}
\usage{
orsf(
  data_train,
  formula,
  control = orsf_control_cph(),
  n_tree = 500,
  n_split = 5,
  n_retry = 0,
  mtry = NULL,
  leaf_min_events = 1,
  leaf_min_obs = 5,
  split_min_events = 5,
  split_min_obs = 10,
  oobag_pred = TRUE,
  oobag_time = NULL,
  oobag_eval_every = n_tree,
  oobag_fun = NULL,
  importance = FALSE,
  attach_data = TRUE,
  no_fit = FALSE
)

orsf_train(object)
}
\arguments{
\item{data_train}{(\emph{data.frame}) that will be used to grow the forest.}

\item{formula}{(\emph{formula}) a formula object, with the response on the left
of a \code{~} operator, and the terms on the right (see details). Variables
on the right hand size of the \code{~} can be numeric, integer, or factor
variables. Factors may be ordered or unordered.}

\item{control}{An \code{aorsf_control} object, created with \link{orsf_control_net}
or \link{orsf_control_cph}. Default is \code{control = orsf_control_cph()}.}

\item{n_tree}{(\emph{integer}) the number of trees to grow.
Default is \code{n_tree = 500.}}

\item{n_split}{(\emph{integer}) the number of cut-points assessed when splitting
a node in decision trees. Default is \code{n_split = 5}.}

\item{n_retry}{(\emph{integer}) when a node can be split, but the current
linear combination of inputs is unable to provide a valid split, \code{orsf}
will try again with a new linear combination based on a different set
of randomly selected predictors, up to \code{n_retry} pred_horizon. When
\code{n_retry = 0} the retry mechanic is not applied.
Default is \code{n_retry = 0}.}

\item{mtry}{(\emph{integer}) Number of variables randomly selected as candidates
for splitting a node. The default is the smallest integer greater than
the square root of the number of features, i.e.,
\verb{mtry = ceiling(sqrt(number of predictors))}}

\item{leaf_min_events}{(\emph{integer}) minimum number of events in a
leaf node. Default is \code{leaf_min_events = 1}}

\item{leaf_min_obs}{(\emph{integer}) minimum number of observations in a
leaf node. Default is \code{leaf_min_obs = 5}}

\item{split_min_events}{(\emph{integer}) minimum number of events required
to split a node. Default is \code{split_min_events = 5}}

\item{split_min_obs}{(\emph{integer}) minimum number of observations required
to split a node. Default is \code{split_min_obs = 10}.}

\item{oobag_pred}{(\emph{logical}) if \code{TRUE} out-of-bag predictions are returned
in the \code{aorsf} object. Default is \code{TRUE}.}

\item{oobag_time}{(\emph{numeric}) A numeric value indicating what time
should be used for out-of-bag predictions. Default is the median
of the observed pred_horizon, i.e., \code{oobag_time = median(time)}.}

\item{oobag_eval_every}{(\emph{integer}) The out-of-bag performance of the
ensemble will be checked every \code{oobag_eval_every} trees. So, if
\code{oobag_eval_every = 10}, then out-of-bag performance is checked
after growing the 10th tree, the 20th tree, and so on. Default
is \code{oobag_eval_every = n_tree}, so that out-of-bag performance is
assessed once after growing all the trees.}

\item{oobag_fun}{(\emph{function}) When \code{oobag_fun} = \code{NULL} (the default),
out-of-bag predictions are evaluated using Harrell's C-statistic.
If a value for \code{oobag_fun} is provided, it will be used in place of
Harrell's C-statistic to evaluate out-of-bag predictions. The function
must have two inputs: \code{y_mat} and \code{s_vec}. The input \code{y_mat} is
presumed to be a matrix with two columns named \code{time} (first column)
and \code{status} (second column). The input \code{s_vec} is presumed to be a
numeric vector containing predicted survival probabilities for \code{y_mat}.}

\item{importance}{(\emph{logical}) if \code{TRUE}, variable importance will be
computed using \emph{negation} importance. With negation importance,
all coefficients for a given variable are multiplied by -1 and
then the out-of-bag error for the forest is re-computed. The greater
the degradation of the forest's error, the more important the variable.
Default is \code{FALSE}. Note that if \code{oobag_fun} is specified above, it
will be used in the computation of negation importance.}

\item{attach_data}{(\emph{logical}) if \code{TRUE}, a copy of the training
data will be attached to the output. This is helpful if you
plan on using functions like \link{orsf_pd_summary} to interpret the fitted
forest using its training data. Default is \code{TRUE}.}

\item{no_fit}{(\emph{logical}) if \code{TRUE}, pre-processing steps are defined and
parametrized, but training is not initiated. The object returned can be
directly submitted to \code{orsf_train()} so long as \code{attach_data} is \code{TRUE}.}

\item{object}{an untrained aorsf object, created by setting
\code{no_fit = TRUE} in \code{orsf()}.}
}
\value{
an accelerated oblique RSF object (\code{aorsf})
}
\description{
Oblique Random Survival Forest (ORSF)
}
\details{
This function is based on and highly similar to the \code{ORSF} function
in the \code{obliqueRSF} R package. The primary difference is that this
function runs much faster. The speed increase is attributable to better
management of memory (i.e., no unnecessary copies of inputs) and using
a Newton Raphson scoring algorithm to identify linear combinations of
inputs rather than performing penalized regression using routines in
\code{glmnet}.The modified Newton Raphson scoring algorithm that this
function applies is an adaptation of the C++ routine developed by
Terry M. Therneau that fits Cox proportional hazards models
(see \code{\link[survival:coxph]{survival::coxph()}} and more specifically \code{\link[survival:agreg.fit]{survival::coxph.fit()}}).

\strong{Some comments on inputs}

\emph{formula}: The response in \code{formula} can be a survival
object as returned by the \link[survival:Surv]{survival::Surv} function,
but can also just be the time and status variables.
For example, \code{Surv(time, status) ~ .} works just like
\code{time + status ~ .}. The only thing that can break this
input is putting the variables in the wrong order, i.e.,
writing \code{status + time ~ .} will make \code{orsf} assume your
\code{status} variable is actually the \code{time} variable.

\emph{mtry}: The \code{mtry} parameter may be temporarily reduced to ensure there
are at least 2 events per predictor variable. This occurs when using
\link{orsf_control_cph} because coefficients in the Newton Raphson scoring
algorithm may become unstable when the number of covariates is
greater than or equal to the number of events. This reduction does not
occur when using \link{orsf_control_net}.#'
}
\examples{


fit <- orsf(pbc_orsf, formula = Surv(time, status) ~ . - id)

print(fit)

}
\references{
Breiman L. Random forests. \emph{Machine learning}. 2001 Oct;45(1):5-32.
DOI: 10.1023/A:1010933404324

Ishwaran H, Kogalur UB, Blackstone EH, Lauer MS. Random survival forests.
\emph{Annals of applied statistics}. 2008 Sep;2(3):841-60.
DOI: 10.1214/08-AOAS169

Jaeger BC, Long DL, Long DM, Sims M, Szychowski JM, Min YI,
Mcclure LA, Howard G, Simon N. Oblique random survival forests.
\emph{Annals of applied statistics}. 2019 Sep;13(3):1847-83.
DOI: 10.1214/19-AOAS1261
}
